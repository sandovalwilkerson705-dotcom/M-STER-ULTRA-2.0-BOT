(async () => {
let canalId = ["120363266665814365@newsletter"];  
let canalNombre = ["ğŸ‘¾ AZURA ULTRA 2.0 BOT ğŸ‘¾"]
  function setupConnection(conn) {
  conn.sendMessage2 = async (chat, content, m, options = {}) => {
    const firstChannel = { 
      id: canalId[0], 
      nombre: canalNombre[0] 
    };
    if (content.sticker) {
      return conn.sendMessage(chat, { 
        sticker: content.sticker 
      }, { 
        quoted: m,
        ...options 
      });
    }
    const messageOptions = {
      ...content,
      mentions: content.mentions || options.mentions || [],
      contextInfo: {
        ...(content.contextInfo || {}),
        forwardedNewsletterMessageInfo: {
          newsletterJid: firstChannel.id,
          serverMessageId: '',
          newsletterName: firstChannel.nombre
        },
        forwardingScore: 9999999,
        isForwarded: true,
        mentionedJid: content.mentions || options.mentions || []
      }
    };

    return conn.sendMessage(chat, messageOptions, {
      quoted: m,
      ephemeralExpiration: 86400000,
      disappearingMessagesInChat: 86400000,
      ...options
    });
  };
}
//nsfw 
async function getPrompt() {
  try {
    const res = await fetch('https://raw.githubusercontent.com/elrebelde21/LoliBot-MD/main/src/text-chatgpt.txt');
    return await res.text();
  } catch {
    return 'Eres un asistente inteligente';
  }
}

function cleanResponse(text) {
  if (!text) return '';
  return text
    .replace(/Maaf, terjadi kesalahan saat memproses permintaan Anda/g, '')
    .replace(/Generated by BLACKBOX\.AI.*?https:\/\/www\.blackbox\.ai/g, '')
    .replace(/and for API requests replace https:\/\/www\.blackbox\.ai with https:\/\/api\.blackbox\.ai/g, '')
    .trim();
}

async function luminaiQuery(q, user, prompt) {
  const { data } = await axios.post('https://luminai.my.id', {
    content: q,
    user: user,
    prompt: prompt,
    webSearchMode: true
  });
  return data.result;
}

async function perplexityQuery(q, prompt) {
  const { data } = await axios.get('https://api.perplexity.ai/chat', {
    params: {
      query: encodeURIComponent(q),
      context: encodeURIComponent(prompt)
    }
  });
  return data.response;
}
  //lumi
    const axios = require("axios");
    const fetch = require("node-fetch");
    const { cargarSubBots } = require("./indexsubbots");
    await cargarSubBots()
    const { default: makeWASocket, useMultiFileAuthState, fetchLatestBaileysVersion, makeCacheableSignalKeyStore } = require("@whiskeysockets/baileys");
    const chalk = require("chalk");
    const yargs = require('yargs/yargs')
    const { tmpdir } = require('os')
    const { join } = require('path')
    const figlet = require("figlet");
    const fs = require("fs");
    const { readdirSync, statSync, unlinkSync } = require('fs')
    const readline = require("readline");
    const pino = require("pino");
    const { isOwner, getPrefix, allowedPrefixes } = require("./config");
    const { handleCommand } = require("./main"); 
    // Carga de credenciales y estado de autenticaciÃ³n
    const { state, saveCreds } = await useMultiFileAuthState("./sessions");
  const { downloadContentFromMessage } = require('@whiskeysockets/baileys');
  //lista
function isAllowedUser(sender) {
  const listaFile = "./lista.json";
  if (!fs.existsSync(listaFile)) return false;
  const lista = JSON.parse(fs.readFileSync(listaFile, "utf-8"));
  // Extrae solo los dÃ­gitos del nÃºmero para comparar
  const num = sender.replace(/\D/g, "");
  return lista.includes(num);
}

    //privado y admins

const path = "./activos.json";

// ğŸ“‚ Cargar configuraciÃ³n de modos desde el archivo JSON
function cargarModos() {
    if (!fs.existsSync(path)) {
        fs.writeFileSync(path, JSON.stringify({ modoPrivado: false, modoAdmins: {} }, null, 2));
    }
    return JSON.parse(fs.readFileSync(path, "utf-8"));
}

// ğŸ“‚ Guardar configuraciÃ³n de modos en el archivo JSON
function guardarModos(data) {
    fs.writeFileSync(path, JSON.stringify(data, null, 2));
}

let modos = cargarModos();

    // ConfiguraciÃ³n de consola
    console.log(chalk.cyan(figlet.textSync("Azura Ultra Bot", { font: "Standard" })));    
    console.log(chalk.green("\nâœ… Iniciando conexiÃ³n...\n"));

    // âœ… Mostrar opciones de conexiÃ³n bien presentadas
    console.log(chalk.yellow("ğŸ“¡ Â¿CÃ³mo deseas conectarte?\n"));
    console.log(chalk.green("  [1] ") + chalk.white("ğŸ“· Escanear cÃ³digo QR"));
    console.log(chalk.green("  [2] ") + chalk.white("ğŸ”‘ Ingresar cÃ³digo de 8 dÃ­gitos\n"));

    // Manejo de entrada de usuario
    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
    const question = (text) => new Promise((resolve) => rl.question(text, resolve));

    let method = "1"; // Por defecto: CÃ³digo QR
    if (!fs.existsSync("./sessions/creds.json")) {
        method = await question(chalk.magenta("ğŸ“ Ingresa tu nÃºmero (Ej: 5491168XXXX) "));

        if (!["1", "2"].includes(method)) {
            console.log(chalk.red("\nâŒ OpciÃ³n invÃ¡lida. Reinicia el bot y elige 1 o 2."));
            process.exit(1);
        }
    }

    async function startBot() {
        try {
            let { version } = await fetchLatestBaileysVersion();
            const socketSettings = {
                printQRInTerminal: method === "1",
                logger: pino({ level: "silent" }),
                auth: { creds: state.creds, keys: makeCacheableSignalKeyStore(state.keys, pino({ level: "silent" })) },
                browser: method === "1" ? ["AzuraBot", "Safari", "1.0.0"] : ["Ubuntu", "Chrome", "20.0.04"],
            };

            const sock = makeWASocket(socketSettings);
setupConnection(sock)
            // Si la sesiÃ³n no existe y se usa el cÃ³digo de 8 dÃ­gitos
            if (!fs.existsSync("./sessions/creds.json") && method === "2") {
                let phoneNumber = await question("ğŸ˜Fino vamos ayağŸ˜: ");
                phoneNumber = phoneNumber.replace(/\D/g, "");
                setTimeout(async () => {
                    let code = await sock.requestPairingCode(phoneNumber);
                    console.log(chalk.magenta("ğŸ”‘ CÃ³digo de vinculaciÃ³n: ") + chalk.yellow(code.match(/.{1,4}/g).join("-")));
                }, 2000);
            }

//_________________

global.opts = new Object(yargs(process.argv.slice(2)).exitProcess(false).parse())

//tmp
if (!opts['test']) {
  setInterval(async () => {
  //  if (global.db.data) await global.db.write().catch(console.error)
    if (opts['autocleartmp']) try {
      clearTmp()

    } catch (e) { console.error(e) }
  }, 60 * 1000)
}

if (opts['server']) (await import('./server.js')).default(global.conn, PORT)

/* Clear */
async function clearTmp() {
  const tmp = [tmpdir(), join(__dirname, './tmp')]
  const filename = []
  tmp.forEach(dirname => readdirSync(dirname).forEach(file => filename.push(join(dirname, file))))

  //---
  return filename.map(file => {
    const stats = statSync(file)
    if (stats.isFile() && (Date.now() - stats.mtimeMs >= 1000 * 60 * 1)) return unlinkSync(file) // 1 minuto
    return false
  })
}

setInterval(async () => {
  await clearTmp()
  console.log(chalk.cyanBright(`â•­â”â”€â”â”€â”â”€â‰ªğŸ”†â‰«â”€â”â”€â”â”€â”â•®\nâ”‚SE LIMPIO LA CARPETA TMP CORRECTAMENTE\nâ•°â”â”€â”â”€â”â”€â‰ªğŸ”†â‰«â”€â”â”€â”â”€â”â•¯`))
}, 1000 * 60 * 60); // â† 1 hora en milisegundos

//sessions/jadibts
            // FunciÃ³n para verificar si un usuario es administrador en un grupo
            async function isAdmin(sock, chatId, sender) {
                try {
                    const groupMetadata = await sock.groupMetadata(chatId);
                    const admins = groupMetadata.participants
                        .filter(p => p.admin)
                        .map(p => p.id);
                    return admins.includes(sender) || isOwner(sender);
                } catch (error) {
                    console.error("Error verificando administrador:", error);
                    return false;
                }
            }

// Ruta de los archivos a limpiar
const archivosAntidelete = [
  './antidelete.json',
  './antideletepri.json',
  './gruposu.json',
  './prisu.json'
];

function limpiarAntidelete() {
  for (const archivo of archivosAntidelete) {
    if (fs.existsSync(archivo)) {
      fs.writeFileSync(archivo, JSON.stringify({}, null, 2));
      console.log(`ğŸ§¹ Archivo limpiado: ${archivo}`);
    }
  }
}

// Ejecutar limpieza cada 30 minutos
setInterval(limpiarAntidelete, 30 * 60 * 1000); // 30 min

// Ejecutar una vez al inicio
limpiarAntidelete();
//cada 30 minutos antidelete          


          // FunciÃ³n para revisar y actualizar grupos cada 5 segundos
setInterval(async () => {
  try {
    const ahora = Date.now();

    // === REVISAR CIERRE AUTOMÃTICO ===
    const tiempoCerrarPath = path.resolve("./tiempo1.json");
    if (fs.existsSync(tiempoCerrarPath)) {
      const tiempoCerrar = JSON.parse(fs.readFileSync(tiempoCerrarPath, "utf-8"));

      for (const groupId of Object.keys(tiempoCerrar)) {
        const tiempoLimite = tiempoCerrar[groupId];
        if (ahora >= tiempoLimite) {
          console.log(`â° Se cumpliÃ³ el tiempo para CERRAR el grupo: ${groupId}`);

          try {
            await sock.groupSettingUpdate(groupId, "announcement"); // Cerrar grupo
            await sock.sendMessage(groupId, {
              text: "ğŸ”’ El grupo ha sido cerrado automÃ¡ticamente. Solo admins pueden escribir."
            });
          } catch (error) {
            console.error(`âŒ Error cerrando grupo ${groupId}:`, error);
          }

          delete tiempoCerrar[groupId];
          fs.writeFileSync(tiempoCerrarPath, JSON.stringify(tiempoCerrar, null, 2));
        }
      }
    }
//limpieza

    // === REVISAR APERTURA AUTOMÃTICA ===
    const tiempoAbrirPath = path.resolve("./tiempo2.json");
    if (fs.existsSync(tiempoAbrirPath)) {
      const tiempoAbrir = JSON.parse(fs.readFileSync(tiempoAbrirPath, "utf-8"));

      for (const groupId of Object.keys(tiempoAbrir)) {
        const tiempoLimite = tiempoAbrir[groupId];
        if (ahora >= tiempoLimite) {
          console.log(`â° Se cumpliÃ³ el tiempo para ABRIR el grupo: ${groupId}`);

          try {
            await sock.groupSettingUpdate(groupId, "not_announcement"); // Abrir grupo
            await sock.sendMessage(groupId, {
              text: "ğŸ”“ El grupo ha sido abierto automÃ¡ticamente. Â¡Todos pueden escribir!"
            });
          } catch (error) {
            console.error(`âŒ Error abriendo grupo ${groupId}:`, error);
          }

          delete tiempoAbrir[groupId];
          fs.writeFileSync(tiempoAbrirPath, JSON.stringify(tiempoAbrir, null, 2));
        }
      }
    }

  } catch (error) {
    console.error("âŒ Error en la revisiÃ³n automÃ¡tica de grupos:", error);
  }
}, 5000); // Revisa cada 5 segundos
//ok de abria onkkkkkk

// Listener para detectar cambios en los participantes de un grupo (bienvenida y despedida)
sock.ev.on("group-participants.update", async (update) => {
  try {
    // Solo operar en grupos
    if (!update.id.endsWith("@g.us")) return;

    const fs = require("fs");
    const activosPath = "./activos.json";
    let activos = {};
    if (fs.existsSync(activosPath)) {
      activos = JSON.parse(fs.readFileSync(activosPath, "utf-8"));
    }

    // ***************** LÃ“GICA ANTIARABE *****************
    // Si la funciÃ³n antiarabe estÃ¡ activada en este grupo...
    if (activos.antiarabe && activos.antiarabe[update.id]) {
      // Lista de prefijos prohibidos (sin el signo +)
      const disallowedPrefixes = [
  "20",   // Egipto ğŸ‡ªğŸ‡¬
  "212",  // Marruecos ğŸ‡²ğŸ‡¦
  "213",  // Argelia ğŸ‡©ğŸ‡¿
  "216",  // TÃºnez ğŸ‡¹ğŸ‡³
  "218",  // Libia ğŸ‡±ğŸ‡¾
  "222",  // Mauritania ğŸ‡²ğŸ‡·
  "224",  // Guinea (algunos bots Ã¡rabes)
  "249",  // SudÃ¡n ğŸ‡¸ğŸ‡©
  "252",  // Somalia ğŸ‡¸ğŸ‡´
  "253",  // Yibuti ğŸ‡©ğŸ‡¯
  "269",  // Comoras ğŸ‡°ğŸ‡²
  "961",  // LÃ­bano ğŸ‡±ğŸ‡§
  "962",  // Jordania ğŸ‡¯ğŸ‡´
  "963",  // Siria ğŸ‡¸ğŸ‡¾
  "964",  // Irak ğŸ‡®ğŸ‡¶
  "965",  // Kuwait ğŸ‡°ğŸ‡¼
  "966",  // Arabia Saudita ğŸ‡¸ğŸ‡¦
  "967",  // Yemen ğŸ‡¾ğŸ‡ª
  "968",  // OmÃ¡n ğŸ‡´ğŸ‡²
  "970",  // Palestina ğŸ‡µğŸ‡¸
  "971",  // Emiratos Ãrabes Unidos ğŸ‡¦ğŸ‡ª
  "972",  // Israel (Ã¡rabes usan sims aquÃ­) ğŸ‡®ğŸ‡±
  "973",  // BarÃ©in ğŸ‡§ğŸ‡­
  "974",  // Catar ğŸ‡¶ğŸ‡¦
  "975",  // ButÃ¡n (no Ã¡rabe, pero spamean desde ahÃ­)
  "976",  // Mongolia (se infiltran bots desde aquÃ­)
  "980",  // Temporal / bots Ã¡rabes
  "992",  // TayikistÃ¡n (usuarios Ã¡rabes islÃ¡micos)
  "998"   // UzbekistÃ¡n (tambiÃ©n islÃ¡mico)
];
      if (update.action === "add") {
        // Obtener metadata del grupo para verificar administradores
        let groupMetadata = {};
        try {
          groupMetadata = await sock.groupMetadata(update.id);
        } catch (err) {
          console.error("Error obteniendo metadata del grupo:", err);
        }
        for (const participant of update.participants) {
          // Extraer el nÃºmero (la parte antes de "@")
          const phoneNumber = participant.split("@")[0];
          // Comprobar si el nÃºmero comienza con alguno de los prefijos prohibidos
          const isDisallowed = disallowedPrefixes.some(prefix => phoneNumber.startsWith(prefix));
          if (isDisallowed) {
            // Verificar si el usuario es admin o propietario
            let bypass = false;
            const participantInfo = groupMetadata.participants.find(p => p.id === participant);
            if (participantInfo && (participantInfo.admin === "admin" || participantInfo.admin === "superadmin")) {
              bypass = true;
            }
            if (!bypass && !isOwner(participant)) {
              // Enviar aviso mencionando al usuario
              await sock.sendMessage(update.id, {
                text: `âš ï¸ @${phoneNumber} tiene un nÃºmero prohibido y serÃ¡ expulsado.`,
                mentions: [participant]
              });
              // Intentar expulsar al usuario
              try {
                await sock.groupParticipantsUpdate(update.id, [participant], "remove");
              } catch (expulsionError) {
                console.error("Error al expulsar al usuario:", expulsionError);
              }
            }
          }
        }
      }
    }
    // **************** FIN LÃ“GICA ANTIARABE ****************

    // **************** LÃ“GICA BIENVENIDA/DESPEDIDA ****************
const welcomeActivo = activos.welcome?.[update.id];
const despedidasActivo = activos.despedidas?.[update.id];

if (!welcomeActivo && !despedidasActivo) return;

const welcomePath = "./welcome.json";
let customWelcomes = {};
if (fs.existsSync(welcomePath)) {
  customWelcomes = JSON.parse(fs.readFileSync(welcomePath, "utf-8"));
}
    // Textos integrados para bienvenida y despedida
    const welcomeTexts = [
      "Â¡Bienvenido(a)! Azura Ultra 2.0 Bot te recibe con los brazos abiertos ğŸ¤—âœ¨. Â¡Disfruta y comparte!",
      "Â¡Hola! Azura Ultra 2.0 Bot te abraza con alegrÃ­a ğŸ‰ğŸ¤–. Â¡PrepÃ¡rate para grandes aventuras!",
      "Â¡Saludos! Azura Ultra 2.0 Bot te da la bienvenida para que descubras ideas brillantes ğŸš€ğŸŒŸ.",
      "Â¡Bienvenido(a) al grupo! Azura Ultra 2.0 Bot te invita a explorar un mundo de posibilidades ğŸ¤©ğŸ’¡.",
      "Â¡QuÃ© alegrÃ­a verte! Azura Ultra 2.0 Bot te recibe y te hace sentir en casa ğŸ ğŸ’–.",
      "Â¡Hola! Gracias por unirte; Azura Ultra 2.0 Bot te saluda con entusiasmo ğŸŠğŸ˜Š.",
      "Â¡Bienvenido(a)! Cada nuevo miembro es una chispa de inspiraciÃ³n en Azura Ultra 2.0 Bot ğŸ”¥âœ¨.",
      "Â¡Saludos cordiales! Azura Ultra 2.0 Bot te envÃ­a un abrazo virtual ğŸ¤—ğŸ’™.",
      "Â¡Bienvenido(a)! Ãšnete a la experiencia Azura Ultra 2.0 Bot y comparte grandes ideas ğŸ‰ğŸŒˆ.",
      "Â¡Hola! Azura Ultra 2.0 Bot te da la bienvenida para vivir experiencias inolvidables ğŸš€âœ¨!"
    ];
    const farewellTexts = [
      "Â¡AdiÃ³s! Azura Ultra 2.0 Bot te despide con gratitud y te desea Ã©xitos en tus nuevos caminos ğŸ‘‹ğŸ’«.",
      "Hasta pronto, desde Azura Ultra 2.0 Bot te deseamos lo mejor y esperamos verte de nuevo ğŸŒŸğŸ™.",
      "Â¡Chao! Azura Ultra 2.0 Bot se despide, pero siempre tendrÃ¡s un lugar si decides regresar ğŸ¤—ğŸ’”.",
      "Nos despedimos con cariÃ±o; gracias por compartir momentos en Azura Ultra 2.0 Bot ğŸ â¤ï¸.",
      "Â¡AdiÃ³s, amigo(a)! Azura Ultra 2.0 Bot te manda un abrazo y te desea mucha suerte ğŸ¤ğŸŒŸ.",
      "Hasta luego, y gracias por haber sido parte de nuestra comunidad ğŸš€ğŸ’™.",
      "Chao, que tus futuros proyectos sean tan brillantes como tÃº ğŸŒŸâœ¨. Azura Ultra 2.0 Bot te recuerda siempre.",
      "Â¡Nos vemos! Azura Ultra 2.0 Bot te dice adiÃ³s con un corazÃ³n lleno de gratitud ğŸ¤—â¤ï¸.",
      "Â¡AdiÃ³s! Que tu camino estÃ© lleno de Ã©xitos, te lo desea Azura Ultra 2.0 Bot ğŸš€ğŸŒŸ.",
      "Hasta pronto, y gracias por haber compartido momentos inolvidables con Azura Ultra 2.0 Bot ğŸ‘‹ğŸ’–."
    ];

// Procesar segÃºn la acciÃ³n: "add" (entrada) o "remove" (salida)

// Si alguien entra y la bienvenida estÃ¡ activa
if (update.action === "add" && welcomeActivo) {
  for (const participant of update.participants) {
    const mention = `@${participant.split("@")[0]}`;
    const customMessage = customWelcomes[update.id];

    // Obtener foto de perfil (o grupo si falla)
    let profilePicUrl;
    try {
      profilePicUrl = await sock.profilePictureUrl(participant, "image");
    } catch (err) {
      try {
        profilePicUrl = await sock.profilePictureUrl(update.id, "image");
      } catch {
        profilePicUrl = "https://cdn.dorratz.com/files/1741323171822.jpg";
      }
    }

    if (customMessage) {
      // Enviar mensaje personalizado
      await sock.sendMessage(update.id, {
        image: { url: profilePicUrl },
        caption: `ğŸ‘‹ ${mention}\n\n${customMessage}`,
        mentions: [participant]
      });
    } else {
      // Elegir mensaje aleatorio
      const mensajeTexto = welcomeTexts[Math.floor(Math.random() * welcomeTexts.length)];
      const option = Math.random();

      if (option < 0.33) {
        await sock.sendMessage(update.id, {
          image: { url: profilePicUrl },
          caption: `ğŸ‘‹ ${mention}\n\n${mensajeTexto}`,
          mentions: [participant]
        });
      } else if (option < 0.66) {
        let groupDesc = "";
        try {
          const metadata = await sock.groupMetadata(update.id);
          groupDesc = metadata.desc ? `\n\nğŸ“œ *DescripciÃ³n del grupo:*\n${metadata.desc}` : "";
        } catch (err) {
          groupDesc = "";
        }

        await sock.sendMessage(update.id, {
          text: `ğŸ‘‹ ${mention}\n\n${mensajeTexto}${groupDesc}`,
          mentions: [participant]
        });
      } else {
        await sock.sendMessage(update.id, {
          text: `ğŸ‘‹ ${mention}\n\n${mensajeTexto}`,
          mentions: [participant]
        });
      }
    }
  }
} else if (update.action === "remove" && despedidasActivo) {
  // Si alguien se va y despedidas estÃ¡ activado
  for (const participant of update.participants) {
    const mention = `@${participant.split("@")[0]}`;
    const mensajeTexto = farewellTexts[Math.floor(Math.random() * farewellTexts.length)];
    const option = Math.random();

    let profilePicUrl;
    try {
      profilePicUrl = await sock.profilePictureUrl(participant, "image");
    } catch (err) {
      profilePicUrl = "https://cdn.dorratz.com/files/1741323171822.jpg";
    }

    if (option < 0.5) {
      await sock.sendMessage(update.id, {
        image: { url: profilePicUrl },
        caption: `ğŸ‘‹ ${mention}\n\n${mensajeTexto}`,
        mentions: [participant]
      });
    } else {
      await sock.sendMessage(update.id, {
        text: `ğŸ‘‹ ${mention}\n\n${mensajeTexto}`,
        mentions: [participant]
      });
    }
  }
}
// **************** FIN LÃ“GICA BIENVENIDA/DESPEDIDA ****************
    // **************** FIN LÃ“GICA BIENVENIDA/DESPEDIDA ****************

  } catch (error) {
    console.error("Error en el evento group-participants.update:", error);
  }
});

            // ğŸŸ¢ Consola de mensajes entrantes con diseÃ±o

sock.ev.on("messages.upsert", async (messageUpsert) => {
  try {
    const msg = messageUpsert.messages[0];
    if (!msg) return;

    const chatId = msg.key.remoteJid;
    const isGroup = chatId.endsWith("@g.us");
 